I prefer solution B because it breaks things up well. The is_palindrome function simply checks a word by itself, and check_all_palindromes uses that function in a loop. This solution is infinitely more useful and testable than solution A because this solution could be used someway down the line if I needed it again but with less words or string-related functions involved. It would be infinitely more helpful if it were used in a new word-related function somewhere down the line because it does not include so many functions that are word/strings-related.
Since Solution A deals with mere three elements, it is quite brittle and would fail as soon as I alter the size of my inputs. Solution C is somewhat better in that it deals with any size array, but it is still redundant in computing all reversals when it could just terminate after spotting the first non-palindrome.
The Solution B absolutely hits it right by checking each word individually to bail right away if something doesn’t match. It just seems so much more efficient, so much more intuitive, so much more like what I’d personally think through in trying to solve this problem.
